<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>GEOSLib docs: Library Functions</TITLE>
 <LINK HREF="geos-4.html" REL=next>
 <LINK HREF="geos-2.html" REL=previous>
 <LINK HREF="geos.html#toc3" REL=contents>
</HEAD>
<BODY>
<A HREF="geos-4.html">Next</A>
<A HREF="geos-2.html">Previous</A>
<A HREF="geos.html#toc3">Contents</A>
<HR>
<H2><A NAME="s3">3.</A> <A HREF="geos.html#toc3">Library Functions</A></H2>

<P>Functions here are sorted more or less in the way they appear in the header files. This way I am able
to keep functions covering similar tasks near each other. All function names are identical to those
from the <CODE>geosSym</CODE> file provided with the GeoProgrammer package. Only my extensions to <CODE>geosSym</CODE>
are covered by new names, but I tried to keep them in the naming convention.</P>

<H2><A NAME="ss3.1">3.1</A> <A HREF="geos.html#toc3.1">Graphics</A>
</H2>

<P>This section covers the drawing package of GEOS along with text output routines.</P>

<H3>SetPattern</H3>

<P><CODE>void SetPattern (char pattern)</CODE></P>
<P>This function sets the current pattern to the given. There are 32 different patterns in GEOS. You can
see them together in the filling box in GeoPaint.</P>

<H3>GraphicsString</H3>

<P><CODE>void GraphicsString (char *myGString)</CODE></P>
<P>One of the more powerfull routines of GEOS. This function calls other graphic functions depending
on the given command string. See the structures chapter for a more detailed description.</P>

<H3>Rectangle functions</H3>

<P>Parameters to those functions are grouped in the <CODE>struct window drawWindow</CODE>. To speed up things and
reduce overhead this structure is bound to zero page locations, where all rectangle functions
expect their parameters. You can modify the data directly (e.g. <CODE>drawWindow.top=10</CODE>) or via the
<CODE>InitDrawWindow</CODE> function. Contents of <CODE>drawWindow</CODE> are guaranteed not to change when only
using graphics functions. In other cases you should keep your data in separate <CODE>struct window</CODE>
and use <CODE>InitDrawWindow</CODE> before the first call to one of the rectangle functions.</P>

<H3>InitDrawWindow</H3>

<P><CODE>void InitDrawWindow (struct window *myWindow)</CODE></P>
<P>This function only copies the contents of <CODE>myWindow</CODE> into the system area of <CODE>drawWindow</CODE>. Use it
if for some reason you have to keep your window data out of the zero page space.</P>

<H3>Rectangle</H3>

<P><CODE>void Rectangle (void)</CODE></P>
<P>This draws on screen a rectangle filled with the current pattern.</P>

<H3>FrameRectangle</H3>

<P><CODE>void FrameRectangle (char pattern)</CODE></P>
<P>This one draws a frame with the given bit pattern (not a pattern from the GEOS palette).</P>

<H3>InvertRectangle</H3>

<P><CODE>void InvertRectangle (void)</CODE></P>
<P>Just as the name says...</P>

<H3>ImprintRectangle and RecoverRectangle</H3>

<P><CODE>void ImprintRectangle (void)</CODE></P>
<P><CODE>void RecoverRectangle (void)</CODE></P>
<P>These two functions are for copying parts of the screen to (<CODE>Imprint</CODE>) and from (<CODE>Recover</CODE>) the
backbuffer of the screen. For example when drawing a new menu box GEOS first uses
<CODE>ImprintRectangle</CODE> to save the area under the box, and restores it by <CODE>RecoverRectangle</CODE> upon
destroying the menu.</P>

<H3>Line Functions</H3>

<P>The GEOS drawing package is optimized so there are different functions for drawing vertical and
horizontal lines.</P>

<H3>HorizontalLine</H3>

<P><CODE>void HorizontalLine (char pattern, char y, unsigned xStart, unsigned xEnd)</CODE></P>
<P>This function draws a horizontal line using the given pattern. Note that <CODE>pattern</CODE> is not a pattern
number as set in <CODE>SetPattern</CODE> but a true bit pattern.</P>

<H3>InvertLine</H3>

<P><CODE>void InvertLine (char y, unsigned xStart, unsigned xEnd)</CODE></P>
<P>There is only a horizontal version.</P>

<H3>RecoverLine</H3>

<P><CODE>void RecoverLine (char y, unsigned xStart, unsigned xEnd)</CODE></P>
<P>This function recovers a single line. It is utilized by <CODE>RecoverRectangle</CODE>. See its description
for more details.</P>

<H3>VerticalLine</H3>

<P><CODE>void VerticalLine (char pattern, char yStart, char yEnd, unsigned x)</CODE></P>
<P>This function draws a vertical line using the given pattern. Note that <CODE>pattern</CODE> is not a pattern
number as set in <CODE>SetPattern</CODE> but a true bit pattern.</P>

<H3>DrawLine</H3>

<P><CODE>void DrawLine (char mode, struct window *myWindow)</CODE></P>
<P>The <CODE>top</CODE> parameters of <CODE>struct window</CODE> describe the starting point of the line, while
<CODE>bottom</CODE> ones are for the ending point. If <CODE>mode</CODE> is <CODE>DRAW_DRAW</CODE> then the current pattern from
<CODE>SetPattern</CODE> is used for drawing. If <CODE>mode</CODE> is <CODE>DRAW_ERASE</CODE> then the line is erased from the
screen. If <CODE>mode</CODE> is <CODE>DRAW_COPY</CODE> then the line is copied from/to back/frontbuffer, according to
the <CODE>dispBufferOn</CODE> setting.</P>

<H3>Point Functions</H3>

<P>The parameters to these two functions are passed by a pointer to an own <CODE>struct pixel</CODE> filled with
proper values.</P>

<H3>DrawPoint</H3>

<P><CODE>void DrawPoint (char mode, struct pixel *myPixel)</CODE></P>
<P>Depending on <CODE>mode</CODE> (see <CODE>DrawLine</CODE>) draws/erases/copies a single point
on the screen.</P>

<H3>TestPoint</H3>

<P><CODE>char TestPoint (struct pixel *myPixel)</CODE></P>
<P>This function tests if the given pixel is set and returns <CODE>true</CODE> (non-zero) or <CODE>false</CODE> (zero).</P>

<H3>Character and string output</H3>

<H3>PutChar</H3>

<P><CODE>void PutChar (char character, char y, unsigned x)</CODE></P>
<P>This function outputs a single character using the current style and font to the screen.</P>

<H3>PutString</H3>

<P><CODE>void PutString (char *myString, char y, unsigned x)</CODE></P>
<P>Same as <CODE>PutChar</CODE> except the fact that you can output a whole <CODE>NULL</CODE>-terminated string.
See <CODE>ggraph.h</CODE> for the list of tokens that you can also place in the string - like <CODE>CBOLDON</CODE> or
<CODE>COUTLINEON</CODE>.</P>

<H3>PutDecimal</H3>

<P><CODE>void PutDecimal (char parameter, unsigned value, char y, unsigned x)</CODE></P>
<P>This function converts <CODE>value</CODE> to its decimal representation and outputs it to the screen.
The <CODE>parameter</CODE> is the field width in pixels (range 1-31) and the mode bits. Depending on them
the string can be filled with zeroes (the string is always 5 characters long) or not and left or right
justified to the given pixel. See <CODE>ggraph.h</CODE> for predefined values for <CODE>parameter</CODE>.</P>

<H3>Font Handling</H3>

<H3>GetCharWidth</H3>

<P><CODE>char GetCharWidth (char character)</CODE></P>
<P>This function returns the real width (in pixels) of the given character with the current font. It can be used
for counting the length of a string on the screen, allowing for indentation or justification.</P>

<H3>LoadCharSet</H3>

<P><CODE>void LoadCharSet (struct fontdesc *myFont)</CODE></P>
<P>This function forces GEOS to use the given font. <CODE>myFont</CODE> should be casted from a
pointer to the start of the area where a record from a font file (VLIR structure) was loaded.</P>

<H3>UseSystemFont</H3>

<P><CODE>void UseSystemFont (void)</CODE></P>
<P>This function forces GEOS to use the built-in BSW font.</P>

<H3>Bitmap handling</H3>

<P>I'm not quite sure how these functions are working (except <CODE>BitmapUp</CODE>) so you should
probably look into the library sources and compare it with your knowledge. Please let me know
if something is wrong or broken.</P>

<H3>BitmapUp</H3>

<P><CODE>void BitmapUp (struct iconpic *myPic)</CODE></P>
<P>This function unpacks the bitmap and places it on the screen - just as you set it in the
<CODE>struct iconpic</CODE> pointer which you pass. See <CODE>gstruct.h</CODE> for a description of this
structure. Note that you can only use packed GEOS bitmaps - a simple Photo Scrap is in this format.</P>

<H3>BitmapClip</H3>

<P><CODE>void BitmapClip (char skipLeft, char skipRight, unsigned skipTop, struct iconpic *myPic)</CODE></P>
<P>This function acts similar to <CODE>BitmapUp</CODE> but you can also define which parts of the bitmap are
to be drawn - you give the number of columns (8-pixel) to skip on the right and left of the bitmap,
and the number of rows to skip from the top if it.</P>

<H3>BitOtherClip</H3>

<P><CODE>void BitOtherClip (void *proc1, void *proc2, char skipLeft, char skip Right, unsigned skipTop,
struct iconpic *myPic)</CODE></P>
<P>Similar to the previous one with some extension. <CODE>proc1</CODE> is called before reading a byte (it
returns in .A the next value), and <CODE>proc2</CODE> is called every time the parser reads a byte which is
not a piece of a pattern (byte of code greater than 219). Both procedures should be written
separately in assembler and declared as <CODE>__fastcall__</CODE> returning char.</P>

<H2><A NAME="ss3.2">3.2</A> <A HREF="geos.html#toc3.2">Menus and Icons</A>
</H2>

<P>Here you will find information about functions related with menus and icons.</P>

<H3>Menus</H3>

<P>Menus are essential for a GUI. GEOS can handle only one menu at a time, but each menu can call
another one, which results in a submenu tree. There can be up to 8 menu levels, each one with up
to 32 items.</P>
<P>Menus are initialized with <CODE>DoMenu</CODE> and then the Kernal takes care of everything. Your code
(called from an event handler) should be a function without parameters, returning void. You should
use <CODE>DoPreviousMenu</CODE> or <CODE>GotoFirstMenu</CODE> at least once in its code to have the screen clean.</P>

<H3>DoMenu</H3>

<P><CODE>void DoMenu (struct menu *myMenu)</CODE></P>
<P>This function initializes the GEOS menu processor and exits. See <CODE>DoMenu structure</CODE> for more
information about it. Know that many GEOS applications just initialize the screen, menu and
exit to the main Kernal loop, this proves the power of <CODE>DoMenu</CODE>.</P>

<H3>ReDoMenu</H3>

<P><CODE>void ReDoMenu (void)</CODE></P>
<P>This simply redraws the menu at the lowest level. It works like calling <CODE>DoMenu</CODE> again with
the same parameters.</P>

<H3>RecoverMenu</H3>

<P><CODE>void RecoverMenu (void)</CODE></P>
<P>This function erases the current menu from the screen. It doesn't change the menu level.</P>

<H3>RecoverAllMenus</H3>

<P><CODE>void RecoverAllMenus (void)</CODE></P>
<P>This calls <CODE>RecoverMenu</CODE> and erases all menus from the screen. Then the menu level is
set to 0 (topmost).</P>

<H3>DoPreviousMenu</H3>

<P><CODE>void DoPreviousMenu (void)</CODE></P>
<P>This functions causes the menu processor to go back one menu level. You should use it in menu
handler code to have the screen clean.</P>

<H3>GotoFirstMenu</H3>

<P><CODE>void GotoFirstMenu (void)</CODE></P>
<P>This one jumps back to the topmost menu. If there is only a menu and one submenu it works the
same as <CODE>DoPreviousMenu</CODE>.</P>

<H3>Icon Functions</H3>

<P>Icons are working similar to menus except the fact that there is only one level. Icons are
defined as a screen area filled with a bitmap, but if you would setup icons and erase the
screen they would still be active and clicking in the place where formerly an icon was would cause
an effect. Similarly if you would setup icons and then turn them off with <CODE>ClearMouseMode</CODE>
the bitmap would still be on the screen but clicking on it would not cause any action.
There is only one, but powerful icon function.</P>

<H3>DoIcons</H3>

<P><CODE>void DoIcons (struct icontab *myIconTab)</CODE></P>
<P>This function initializes all icons that are present on the screen at once. For more information
look at the <CODE>Icons</CODE> chapter in this manual.</P>

<H2><A NAME="ss3.3">3.3</A> <A HREF="geos.html#toc3.3">DialogBoxes</A>
</H2>

<P>This chapter covers the most powerful GEOS user interface function - <CODE>DoDlgBox</CODE>.</P>

<H3>GEOS standard</H3>

<H3>DoDlgBox</H3>

<P><CODE>char DoDlgBox (char *dialogString)</CODE></P>
<P>This function returns one byte. It can be the value of one of six standard icons (see <CODE>gdlgbox.h</CODE>)
or whatever the closing routine passes. Register <CODE>r0L</CODE> also contains this value.</P>
<P>Read the structures chapter for the specs of the <CODE>dialogString</CODE>.</P>

<H3>RstrFrmDialogue</H3>

<P><CODE>char RstrFrmDialogue</CODE></P>
<P>This function is called from within DoDlgBox event. It immediately closes the DialogBox and returns
the owner ID (or whatever caller has in the .A register).</P>

<H3>GEOSLib extensions</H3>

<P>To simplify the usage of DoDlgBox from C I wrote some helper functions - wrappers for DoDlgBox,
with predefined data. In one word - these are standard DialogBoxes you can see in almost every
GEOS application.</P>

<H3>DlgBoxYesNo, DlgBoxOkCancel, DlgBoxOk</H3>

<P><CODE>char DlgBoxYesNo (char *line1, char *line2)</CODE></P>
<P><CODE>char DlgBoxOkCancel (char *line1, char *line2)</CODE></P>
<P><CODE>void DlgBoxOk (char *line1, char *line2)</CODE></P>
<P>These function show two lines of text in a standard-sized DialogBox. You can read the code of the
pressed icon from the return value. E.g. for <CODE>DlgBoxYesNo</CODE> it can only be <CODE>YES</CODE> or <CODE>NO</CODE>.
You can pass an empty string or NULL to get a blank line.</P>

<H3>DlgBoxGetString</H3>

<P><CODE>char DlgBoxGetString (char *string, char strlen, char *line1, char *line2)</CODE></P>
<P>This function prompts the user to enter a string of at most <CODE>strlen</CODE> characters. It is returned
in <CODE>string</CODE>. The two given lines of text are shown above the input line. Please remember
that there is also a <CODE>CANCEL</CODE> icon in the DialogBox and you should test if user confirmed his
input or gave up. The <CODE>string</CODE> is also shown so you can place a default input there or remember
to place <CODE>NULL</CODE> at start.</P>

<H3>DlgBoxFileSelect</H3>

<P><CODE>char DlgBoxFileSelect (char *class, char filetype, char *filename)</CODE></P>
<P>This routine is the standard file selector. It can return <CODE>OPEN</CODE>, <CODE>CANCEL</CODE> or disk error
on reading the directory or opening the disk.
There is also a <CODE>DISK</CODE> icon shown, but it is handled internally. You pass as input parameters
<CODE>filetype</CODE> and a pointer to a string containing the first part of a file's class. If this string is
empty (<CODE>NULL</CODE> at the start), then all files with given filetype will be shown.</P>
<P>At present this file selector handles only first 16 files of given type and supports only one
(current) drive.</P>

<H3>MessageBox</H3>

<P><CODE>char MessageBox (char mode, const char *format, ...)</CODE></P>
<P>This function is a more general one. It works very much like <CODE>printf</CODE> in a
box. The only difference is the <CODE>mode</CODE> parameter which allows for placing
default icons (see <CODE>gdlgbox.h</CODE> for list of possible <CODE>MB_</CODE> values).
Any too wide text will be clipped to the size of the default window. If <CODE>mode</CODE>
is invalid or equal to <CODE>MB_EMPTY</CODE> then the window will be closed
after a click. Otherwise the user must choose an icon.</P>
<P>Note: Use it if you really need (or if you use it in many places) as
it adds quite amount of code to your program.</P>
<P>Note: the formatted text <EM>cannot exceed</EM> 255 bytes in length, there is no check
for that.</P>

<H2><A NAME="ss3.4">3.4</A> <A HREF="geos.html#toc3.4">Mouse, Sprites and Cursors</A>
</H2>

<P>You will find here functions related to sprite and mouse drawing and handling.</P>

<H3>Mouse related functions</H3>

<P>These cover the mouse - as a general pointing device, but expect users to utilize as different devices
as a digital or analog joystick, a mouse, a lightpen or a koalapad (whatever it is).</P>

<H3>StartMouseMode</H3>

<P><CODE>void StartMouseMode (void)</CODE></P>
<P>This function initializes the mouse vectors - <CODE>mouseVector</CODE> and <CODE>mouseFaultVec</CODE>, and then
calls <CODE>MouseUp</CODE>.</P>

<H3>ClearMouseMode</H3>

<P><CODE>void ClearMouseMode (void)</CODE></P>
<P>This function disables all mouse activities - icons and menus stop to respond to mouse events,
but they are not cleared from the screen.</P>

<H3>MouseUp and MouseOff</H3>

<P><CODE>void MouseUp (void)</CODE></P>
<P><CODE>void MouseOff (void)</CODE></P>
<P>The first function turns the mouse pointer on. It appears on the next IRQ. The second one does
the opposite - it turns off the pointer, but its position is still updated by the input driver.</P>

<H3>IsMseInRegion</H3>

<P><CODE>char IsMseInRegion (struct window *myWindow)</CODE></P>
<P>This function tests if the mouse pointer is actually in the given range of the screen. See <CODE>gsprite.h</CODE> for
a description of the bits in the return values - they describe the position in detail.</P>

<H3>Sprites</H3>

<P>You are free to use any of the eight sprites, but keep in mind that sprite 0 is actually the mouse
pointer and sprite 1 can be overwritten when using a text prompt. You don't have to worry about
40/80 column issues because GEOS128 has a pretty good sprite emulator for the VDC.</P>

<H3>DrawSprite</H3>

<P><CODE>void DrawSprite (char sprite, char *mySprite)</CODE></P>
<P>This function initializes the sprite data. <CODE>mySprite</CODE> is a 63-byte table with bitmap data, which
is copied to the system sprite area (at <CODE>sprpic</CODE> - see <CODE>gsym.h</CODE>). Hardware sprite registers are
not initialized and the sprite is not yet visible.</P>

<H3>PosSprite</H3>

<P><CODE>void PosSprite (char sprite, struct pixel *myPixel)</CODE></P>
<P>This function positions the sprite on the screen. The given coordinates are screen ones - they are
converted to sprite coordinates by GEOS. Due to this you cannot use this function to position your
sprite off the left or top to the screen.</P>

<H3>EnablSprite and DisablSprite</H3>

<P><CODE>void EnablSprite (char sprite)</CODE></P>
<P><CODE>void DisablSprite (char sprite)</CODE></P>
<P>These two functions are responsible for making the sprite visible or not.</P>

<H3>Cursors and Console</H3>

<H3>InitTextPrompt</H3>

<P><CODE>void InitTextPrompt (char height)</CODE></P>
<P>This function initializes sprite 1 for a text prompt with given <CODE>height</CODE>. This parameter can be in
range 1-48.</P>

<H3>PromptOn and PromptOff</H3>

<P><CODE>void PromptOn (struct pixel *myPixel)</CODE></P>
<P><CODE>void PromptOff (void)</CODE></P>
<P>The first function places a text prompt in given place and enables blinking.
The second one is pretty self-explanatory.</P>

<H3>GetNextChar</H3>

<P><CODE>char GetNextChar (void)</CODE></P>
<P>This function gets the next character from the keyboard queue. If the queue is empty it returns
<CODE>NULL</CODE>, otherwise you receive the true ASCII code of a character or the value of a special (function)
key. See <CODE>gsprite.h</CODE> for the list of them.</P>

<H2><A NAME="ss3.5">3.5</A> <A HREF="geos.html#toc3.5">Disk</A>
</H2>

<P>This chapter covers rather low-level disk routines. You should use them with care, because
you may easily corrupt data on disks. Also remember that contemporary GEOS supports many various
devices and sticking to 1541 track layout (e.g. expecting the directory on track 18) might be
dangerous.</P>
<P>For some purposes you might consider using the <CODE>dio.h</CODE> interface to disk access. It is native.</P>
<P>All GEOS disk functions return an error code in the X register. In some cases this is returned by the
GEOSLib function (if its type is <CODE>char</CODE>), but in all cases the last error is saved in the <CODE>__oserror</CODE>
location. If it is nonzero - an error occured. See <CODE>gdisk.h</CODE> for the list of possible errorcodes.
You need to include <CODE>errno.h</CODE> to get <CODE>__oserror</CODE>, together with the standard <CODE>errno</CODE>. The
latter gives less verbose, but still usable information and can be used with <CODE>strerror</CODE>.
Probably you will get more information using <CODE>_stroserror</CODE> in a similar way.</P>
<P>For passing parameters use almost always a pointer to your data e.g. <CODE>ReadBuff (&amp;myTrSe)</CODE>.</P>

<H3>Buffer functions</H3>

<P>These functions take a single data sector (256 bytes) to read or write on the disk.</P>

<H3>ReadBuff and Writebuff</H3>

<P><CODE>char ReadBuff (struct tr_se *myTrSe)</CODE></P>
<P><CODE>char WriteBuff (struct tr_se *myTrSe)</CODE></P>
<P>These functions read and write a sector placed at <CODE>diskBlkBuf</CODE>.</P>

<H3>GetBlock and ReadBlock</H3>

<P><CODE>char GetBlock (struct tr_se *myTrSe, char *buffer)</CODE></P>
<P><CODE>char ReadBlock (struct tr_se *myTrSe, char *buffer)</CODE></P>
<P>These two functions read a single block directly to the 256 byte array placed at <CODE>buffer</CODE>.
The difference between them is that <CODE>GetBlock</CODE> initializes TurboDos in the drive if it was not
enabled. <CODE>ReadBlock</CODE> assumes that it is already enabled thus being slightly faster.</P>

<H3>PutBlock, WriteBlock, VerWriteBlock</H3>

<P><CODE>char PutBlock (struct tr_se *myTrSe, char *buffer)</CODE></P>
<P><CODE>char WriteBlock (struct tr_se *myTrSe, char *buffer)</CODE></P>
<P><CODE>char VerWriteBlock (struct tr_se *myTrSe, char *buffer)</CODE></P>
<P>Similar to previous but needed for writing the disk. <CODE>VerWriteBlock</CODE> verifies the data after
writing. In case of an error five tries are attempted before an error code is returned.</P>

<H3>Directory header</H3>

<P>The functions described here operate on <CODE>curDirHeader</CODE> where the current disk header is stored.
On larger (than 1541) capacity drives the second part of the directory header is in <CODE>dir2Head</CODE>.</P>

<H3>GetPtrCurDkNm</H3>

<P><CODE>void GetPtrCurDkNm (char *diskName)</CODE></P>
<P>This function fills the given character string with the name of current disk. It is converted to C
standard - the string is terminated with <CODE>NULL</CODE> character instead of code 160 as in Commodore DOS.
Note that the passed pointer must point to an array of at least 17 bytes.</P>

<H3>GetDirHead and PutDirHead</H3>

<P><CODE>char GetDirHead (void)</CODE></P>
<P><CODE>char PutDirHead (void)</CODE></P>
<P>These functions read and write the directory header. You should use <CODE>GetDirHead</CODE> before
using any functions described below, and you should use <CODE>PutDirHead</CODE> to save the changes on the
disk. Otherwise they will be lost. Operating area is the <CODE>curDirHead</CODE>.</P>

<H3>CalcBlksFree</H3>

<P><CODE>unsigned CalcBlksFree (void)</CODE></P>
<P>This function returns the number of free blocks on the current disk. It is counted using data in
<CODE>curDirHead</CODE> so you must initialize the disk before calling it.</P>

<H3>ChkDskGEOS</H3>

<P><CODE>char ChkDskGEOS (void)</CODE></P>
<P>This functions checks <CODE>curDirHead</CODE> for the GEOS Format identifier. It returns either true or false,
and also sets <CODE>isGEOS</CODE> properly. You must initialize the disk before using this.</P>

<H3>SetGEOSDisk</H3>

<P><CODE>char SetGEOSDisk (void)</CODE></P>
<P>This function initializes disk for use with GEOS. It sets the indicator in directory header and
allocates a sector for the directory of border files. You don't need to initialize the disk before
using.</P>

<H3>FindBAMBit</H3>

<P><CODE>char FindBAMBit (struct tr_se *myTrSe)</CODE></P>
<P>This function returns the bit value from the BAM (Block Allocation Map) for the given sector. The bit is
set if the sector is free to use. The returned value is always zero if the sector is already allocated.
In fact, this function could be used in a following way:
<BLOCKQUOTE><CODE>
<PRE>
#define BlockInUse FindBAMBit
...
if (!BlockInUse(&amp;myTrSe)) {
... block not allocated ...
}
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Anyway, I feel that this function is too low-level.</P>

<H3>BlkAlloc and NxtBlkAlloc</H3>

<P><CODE>char BlkAlloc (struct tr_se output[], unsigned length)</CODE></P>
<P><CODE>char NxtBlkAlloc (struct tr_se *myTrSe, struct tr_se output[], unsigned length)</CODE></P>
<P>Both functions allocate enough disk sectors to fit <CODE>length</CODE> bytes in them. You
find the output in <CODE>output</CODE> which is a table of <CODE>struct tr_se</CODE>. The last entry will have the
track equal to 0 and sector equal to 255. The simplest way of using them is to use
predefined space in the GEOS data space and pass <CODE>fileTrScTab</CODE>, which is a predefined table.</P>
<P>The difference between those two is that <CODE>NextBlkAlloc</CODE> starts allocating from the given sector,
and <CODE>BlkAlloc</CODE> starts from the first nonused sector.</P>
<P>You need to use <CODE>PutDirHead</CODE> later to save any changes in BAM.</P>

<H3>FreeBlock</H3>

<P><CODE>char FreeBlock (struct tr_se *myTrSe)</CODE></P>
<P>Simply deallocates a block in the BAM. You need to update the BAM with <CODE>PutDirHead</CODE>.</P>

<H3>SetNextFree</H3>

<P><CODE>struct tr_se SetNextFree (struct tr_se *myTrSe)</CODE></P>
<P>This function finds the first free sector starting from given track and sector and allocates it.
It might return the same argument if the given block is not allocated. I wanted it to be type
clean, but this made the usage a bit tricky. To assign a value to your own <CODE>struct tr_se</CODE> you have to
cast both variables to <CODE>unsigned</CODE>. E.g.
<BLOCKQUOTE><CODE>
<PRE>
struct tr_se myTrSe;
...
(unsigned)myTrSe=(unsigned)SetNextFree(&amp;otherTrSe);
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>In this example <CODE>otherTrSe</CODE> can be replaced by <CODE>myTrSe</CODE>.</P>
<P>Note: you <EM>must</EM> use casting to have the correct values.</P>

<H3>Low-level disk IO</H3>

<P>Functions described here are more usable in Kernal or drivers code, less common in applications,
but who knows, maybe someone will need them.</P>

<H3>EnterTurbo, ExitTurbo, PurgeTurbo</H3>

<P><CODE>void EnterTurbo (void)</CODE></P>
<P><CODE>void ExitTurbo (void)</CODE></P>
<P><CODE>void PurgeTurbo (void)</CODE></P>
<P>These functions are the interface to the GEOS TurboDos feature which makes slow Commodore drives a bit
more usable. <CODE>EnterTurbo</CODE> enables TurboDos unless it is already enabled. If not, then you will
have to wait a bit to transfer the TurboDos code into disk drive RAM. <CODE>ExitTurbo</CODE> disables TurboDos.
This is useful for sending some DOS commands to a drive e.g. for formatting. Note that before any
interaction with the Kernal in ROM you have to call <CODE>InitForIO</CODE>. You don't have to worry about speed.
<CODE>EnterTurbo</CODE> will only enable TurboDos (no code transfer) if TurboDos was disabled with
<CODE>ExitTurbo</CODE>. <CODE>PurgeTurbo</CODE> acts differently from <CODE>ExitTurbo</CODE> - it not only disables TurboDos,
but also removes it from drive RAM (not quite true, but it works like that). After using
<CODE>PurgeTurbo</CODE> the next call to <CODE>EnterTurbo</CODE> will reload drive RAM.</P>

<H3>ChangeDiskDevice</H3>

<P><CODE>char ChangeDiskDevice (char newDevice)</CODE></P>
<P>This function changes the device number of the current device (in fact drives only) to the given one. It is
usable for swapping drives. There's no check if the given <CODE>newDevice</CODE> already exist, so if you want
to change the logical number of drive 8 to 9 and you already have a drive number 9 then GEOS will probably
hang on disk access. Use safe, large numbers. Note that the safe IEC range is 8-30.</P>

<H3>Disk Initialization</H3>

<P>GEOS has two functions for initialization ('logging in' as they say on CP/M) of a disk.</P>
<H3>OpenDisk</H3>

<P><CODE>char OpenDisk (void)</CODE></P>
<P>This function initializes everything for a new disk. It loads and enables TurboDos if needed.
Then the disk is initialized with <CODE>NewDisk</CODE>. Next, <CODE>GetDirHead</CODE> initializes <CODE>curDirHead</CODE>.
Disk names are compared and if they differ then the disk cache on REU is cleared. Finally the format is
checked with <CODE>ChkDkGEOS</CODE> and the disk name is updated in the internal tables.</P>

<H3>NewDisk</H3>

<P><CODE>char NewDisk (void)</CODE></P>
<P>This function is similar to the DOS command I. It clears the REU cache and enables TurboDos if needed.</P>

<H2><A NAME="ss3.6">3.6</A> <A HREF="geos.html#toc3.6">Files</A>
</H2>

<P>This section covers the GEOS file interface.</P>

<H3>Directory handling</H3>

<P>The functions described here are common for SEQ and VLIR structures.</P>

<H3>Get1stDirEntry and GetNxtDirEntry</H3>

<P><CODE>struct filehandle *Get1stDirEntry (void)</CODE></P>
<P><CODE>struct filehandle *GetNxtDirEntry (void)</CODE></P>
<P>These two functions are best suited for scanning the whole directory for particular files. Note that
the returned filehandles describe all file slots in the directory - even those with deleted files.
The return value can be obtained by casting both sides to <CODE>unsigned</CODE> - as in the <CODE>SetNextFree</CODE>
function or read directly after a call to those two functions from <CODE>r5</CODE>. The current sector number
is in <CODE>r1</CODE> and the sector data itself is in <CODE>diskBlkBuf</CODE>.</P>

<H3>FindFile</H3>

<P><CODE>char FindFile (char *fName)</CODE></P>
<P>This function scans the whole directory for the given filename. It returns either 0 (success) or 5
(FILE_NOT_FOUND, defined in <CODE>gdisk.h</CODE>) or any other fatal disk read error. After a successful
<CODE>FindFile</CODE> you will have <CODE>struct filehandle</CODE> at <CODE>dirEntryBuf</CODE> filled with the file's data and
other registers set as described in <CODE>GetNxtDirEntry</CODE>.</P>

<H3>FindFTypes</H3>

<P><CODE>char FindFTypes (char *buffer, char fType, char fMaxNum, char *classTxt)</CODE></P>
<P>This function scans the directory and fills a table at <CODE>buffer</CODE> with <CODE>char [17]</CODE> entries.
<CODE>fType</CODE> is the GEOS type of the searched files and <CODE>classTxt</CODE> is a string for the Class field in the file
header. Class matches if the given string is equal or shorter than that found in the file's header block.
If you want just to find all files with the given GEOS type you should pass an empty string or <CODE>NULL</CODE> as
<CODE>classTxt</CODE>. Be warned that for searching <CODE>NON_GEOS</CODE> files you must pass <CODE>NULL</CODE> as <CODE>classTxt</CODE>.
<CODE>fMaxNum</CODE> is the maximal number of files to find, thus the <CODE>buffer</CODE> must provide an area of size
equal to <CODE>17 * fMaxNum</CODE>. This function returns the number of found files, ranging from 0 to number
passed as <CODE>fMaxNum</CODE>. The return value can be also restored from <CODE>r7H</CODE>.</P>

<H3>DeleteFile</H3>

<P><CODE>char DeleteFile (char *fName)</CODE></P>
<P>This function deletes a file by its name. It works for SEQ and VLIR files.</P>

<H3>RenameFile</H3>

<P><CODE>char RenameFile (char *oldName, char *newName)</CODE></P>
<P>I think it is obvious...</P>

<H3>GetFHdrInfo</H3>

<P><CODE>char GetFHdrInfo (struct filehandle *myFile)</CODE></P>
<P>This function loads the file header into the <CODE>fileHeader</CODE> buffer. Using after e.g. <CODE>FindFile</CODE>
you can pass the address of <CODE>dirEntryBuf</CODE>.</P>

<H3>Common and SEQ structure</H3>

<P>Functions described here are common for SEQ and VLIR structures because the arguments passed are the
starting track and sector which may point either to the start of a chain for VLIR or the data for SEQ.</P>

<H3>GetFile</H3>

<P><CODE>char __fastcall__ GetFile(char flag, const char *fname, const char *loadaddr, const char *datadname, const char *datafname)</CODE></P>
<P>This routine loads and runs a given file <CODE>fname</CODE>. The file must be one of following types:
<CODE>SYSTEM, DESK_ACC, APPLICATION, APPL_DATA, PRINTER,</CODE> or <CODE>INPUT_DEVICE</CODE>. The execution
address is taken from the file header. If it is zero, then the file is only loaded. Only the first chain
from VLIR files is loaded. If <CODE>flag</CODE> has bit 0 set then the load address is taken from <CODE>loadaddr</CODE>
and not from the file header. In this case <CODE>APPLICATION</CODE> files will be only loaded, not executed.
This does not apply to <CODE>DESK_ACC</CODE>. If either bit 6 or 7 of <CODE>flag</CODE> are set, then 16 bytes from
<CODE>datadname</CODE> are copied to <CODE>dataDiskName</CODE> and 16 bytes from <CODE>datafname</CODE> go to <CODE>dataFileName</CODE>
thus becoming parameters for the new application. Pass <CODE>NULL</CODE> for any unused parameter.</P>

<H3>ReadFile</H3>

<P><CODE>char ReadFile (struct tr_se *myTrSe, char *buffer, unsigned fLength)</CODE></P>
<P>This function reads at most <CODE>fLength</CODE> bytes into <CODE>buffer</CODE> from chained sectors starting at
<CODE>myTrSe</CODE>.</P>

<H3>ReadByte</H3>

<P><CODE>char ReadByte (void)</CODE></P>
<P>This function returns the next byte from a file. Before the first call to it you must load <CODE>r5</CODE>
with <CODE>NULL</CODE>, <CODE>r4</CODE> with the sector buffer address and <CODE>r1</CODE> with the track and sector of the
first block of a file.
Remember to not modify <CODE>r1</CODE>, <CODE>r4</CODE> and <CODE>r5</CODE>. These registers must be preserved between
calls to <CODE>ReadByte</CODE>.</P>
<P>The returned value is valid only if there was no error. The end of file is marked as <CODE>BFR_OVERFLOW</CODE>
in <CODE>__oserror</CODE>, this is set when trying to read one byte after the end of file, in this case the
returned value is invalid.</P>

<H3>SaveFile</H3>

<P><CODE>char SaveFile (char skip, struct fileheader *myHeader)</CODE></P>
<P><CODE>SaveFile</CODE> will take care of everything needed to create a GEOS file, no matter if VLIR of SEQ
structure. All you need to do is to place the data in the proper place and prepare a header which will
contain all information about a file. The <CODE>skip</CODE> parameter says how many directory pages you
want to skip before searching for a free slot for the directory entry. In most cases you will put
<CODE>0</CODE> there.</P>
<P>You have to declare a <CODE>struct fileheader</CODE> and fill it with proper values. There is only one
difference - the first two bytes which are a link to a nonexistent next sector are replaced by a
pointer to the DOS filename of the file.</P>
<P>When saving sequential files the two most important fields in <CODE>struct fileheader</CODE> are <CODE>fileheader.load_address</CODE>
and <CODE>fileheader.end_address</CODE>.</P>

<H3>FreeFile</H3>

<P><CODE>char FreeFile (struct tr_se myTable[])</CODE></P>
<P>This function deallocates all sectors contained in the passed table.</P>

<H3>FollowChain</H3>

<P><CODE>char FollowChain(struct tr_se *myTrSe, char *buffer)</CODE></P>
<P>This function fills a <CODE>struct tr_se</CODE> table at <CODE>buffer</CODE> with the sector numbers for a chain of
sectors starting with <CODE>myTrSe</CODE>. You can pass such data (<CODE>buffer</CODE>) to e.g. <CODE>FreeFile</CODE>.</P>

<H3>VLIR structure</H3>

<P>Here is information about VLIR files (later called RecordFiles) and functions.</P>
<P>A VLIR structure file consists of up to 127 SEQ-like files called records. Each record is like one
SEQ structure file. Records are grouped together, described by a common name - the VLIR file name and
an own number. Each record pointed to by its number is described by the starting track and sector numbers.
VLIR structures allow records to be empty (<CODE>tr_se</CODE> of such record is equal to <CODE>{NULL,$ff}</CODE>),
or even non-exist (<CODE>{NULL,NULL}</CODE>). Any other numbers represent the starting track and sector of
a particular file.</P>
<P>In GEOS there can be only one file opened at a time. Upon opening a VLIR file some information
about it is copied into memory. You can retrieve the records table at <CODE>fileTrScTab</CODE> (table of
128 <CODE>struct tr_se</CODE>) and from <CODE>VLIRInfo</CODE> (<CODE>struct VLIR_info</CODE>.
E.g. the size of whole VLIR file can be retrieved by reading <CODE>VLIRInfo.fileSize</CODE>.</P>

<H3>OpenRecordFile</H3>

<P><CODE>char OpenRecordFile (char *fName)</CODE></P>
<P>This function finds and opens a given file. An error is returned if the file is not found or if it is not
in VLIR format. Information in <CODE>VLIRInfo</CODE> is initialized. VLIR track and sector table is
loaded at <CODE>fileTrScTab</CODE> and will be valid until a call to <CODE>CloseRecordFile</CODE> so don't modify it.
You should call <CODE>PointRecord</CODE> before trying to do something with the file.</P>

<H3>CloseRecordFile</H3>

<P><CODE>char CloseRecordFile (void)</CODE></P>
<P>This function calls <CODE>UpdateRecordFile</CODE> and clears internal GEOS variables.</P>

<H3>UpdateRecordFile</H3>

<P><CODE>char UpdateRecordFile (void)</CODE></P>
<P>This function will check the <CODE>VLIRInfo.fileWritten</CODE> flag and if it is set, then <CODE>curDirHead</CODE> is
updated along with size and date stamps in the directory entry.</P>

<H3>PointRecord</H3>

<P><CODE>char PointRecord (char recordNumber)</CODE></P>
<P>This function will setup internal variables (and <CODE>VLIRInfo.curRecord</CODE>) and return the track and
sector of the given record in <CODE>r1</CODE>. Note that the data may not be valid (if the record is non-existing
you will get 0,0 and if it is empty - 255,0).</P>

<H3>NextRecord and PreviousRecord</H3>

<P><CODE>char NextRecord (void)</CODE></P>
<P><CODE>char PreviousRecord (void)</CODE></P>
<P>These two work like <CODE>PointRecord</CODE>. Names are self-explanatory.</P>

<H3>AppendRecord</H3>

<P><CODE>char AppendRecord (void)</CODE></P>
<P>This function will append an empty record (pair of 255,0) to the current VLIR track and sector
table. It will also set <CODE>VLIRInfo.curRecord</CODE> to its number.</P>

<H3>DeleteRecord</H3>

<P><CODE>char DeleteRecord (void)</CODE></P>
<P>This function will remove the current record from the table, and move all current+1 records one place
back (in the table). Note that there's no BAM update and you must call <CODE>UpdateRecordFile</CODE> to
commit changes.</P>

<H3>InsertRecord</H3>

<P><CODE>char InsertRecord (void)</CODE></P>
<P>This function will insert an empty record in place of <CODE>VLIRInfo.curRecord</CODE> and move all following
records in the table one place forward (contents of <CODE>VLIRInfo.curRecord</CODE> after a call to <CODE>InsertRecord</CODE>
can be found in <CODE>VLIRInfo.curRecord + 1</CODE>).</P>

<H3>ReadRecord and WriteRecord</H3>

<P><CODE>char ReadRecord (char *buffer, unsigned fLength)</CODE></P>
<P><CODE>char WriteRecord (char *buffer, unsigned fLength)</CODE></P>
<P>This function will load or save at most <CODE>fLength</CODE> bytes from the currently pointed record into or from
<CODE>buffer</CODE>.</P>

<H2><A NAME="ss3.7">3.7</A> <A HREF="geos.html#toc3.7">Memory and Strings</A>
</H2>

<P>The functions covered in this section are common for the whole C world - copying memory parts and
strings is one of the main computer tasks. GEOS also has an interface to do this. These functions
are replacements for those like <CODE>memset, memcpy, strcpy</CODE> etc. from standard libraries.
If you are dealing with short strings (up to 255 characters) you should use these functions
instead of standard ones, e.g. <CODE>CopyString</CODE> instead of <CODE>strcpy</CODE>. It will work faster.</P>
<P>However some of them have slightly different calling conventions (order of arguments to be specific),
so please check their syntax here before a direct replacement.</P>
<P>Please note that the memory areas described here as <EM>strings</EM> are up to 255 characters (without
counting the terminating <CODE>NULL</CODE>), and <EM>regions</EM> can cover the whole 64K of memory.</P>

<H3>CopyString</H3>

<P><CODE>void CopyString (char *dest, char *src)</CODE></P>
<P>This function copies the string from <CODE>src</CODE> to <CODE>dest</CODE>, until it reaches <CODE>NULL</CODE>. The <CODE>NULL</CODE>
is also copied.</P>

<H3>CmpString</H3>

<P><CODE>char CmpString (char *s1, char *s2)</CODE></P>
<P>This function compares the strings <CODE>s1</CODE> to <CODE>s2</CODE> for equality - this is case sensitive, and both
strings have to have the same length. It returns either <CODE>true</CODE> (non-zero) or <CODE>false</CODE> (zero).</P>

<H3>CopyFString and CmpFString</H3>

<P><CODE>void CopyFString (char length, char *dest, char *src)</CODE></P>
<P><CODE>char CmpFString (char length, char *s1, char *s2)</CODE></P>
<P>These two are similar to <CODE>CopyString</CODE> and <CODE>CmpString</CODE> except the fact, that you provide
the length of the copied or compared strings. The strings can also contain several <CODE>NULL</CODE>
characters - they are not treated as delimiters.</P>

<H3>CRC</H3>

<P><CODE>unsigned CRC (char *src, unsigned length)</CODE></P>
<P>This function calculates the CRC checksum for the given memory range. I don't know if it is
compatible with standard CRC routines.</P>

<H3>FillRam and ClearRam</H3>

<P><CODE>void *FillRam (char *dest, char value, unsigned length)</CODE></P>
<P><CODE>void *ClearRam (char *dest, unsigned length)</CODE></P>
<P>Both functions are filling the given memory range. <CODE>ClearRam</CODE> fills with <CODE>0s</CODE>, while
<CODE>FillRam</CODE> uses the given <CODE>value</CODE>. Be warned that these functions destroy <CODE>r0, r1 and
r2L</CODE> registers. The functions are aliases for <CODE>memset</CODE> and <CODE>bzero</CODE>, respectively.</P>

<H3>MoveData</H3>

<P><CODE>void *MoveData (char *dest, char *src, unsigned length)</CODE></P>
<P>This functions copies one memory region to another. There are checks for an overlap and the
non-destructive method is chosen. Be warned that this function destroys contents of the
<CODE>r0, r1 and r2</CODE> registers. This function is an alias for <CODE>memcpy</CODE>.</P>

<H3>InitRam</H3>

<P><CODE>void InitRam (char *table)</CODE></P>
<P>This function allows to initialize multiple memory locations with single bytes or strings.
This is done with a <CODE>table</CODE> where everything is defined. See the structures chapter for a description of
<CODE>InitRam's</CODE> command string.</P>

<H3>StashRAM, FetchRAM, SwapRAM, and VerifyRAM</H3>

<P><CODE>void StashRAM (char bank, unsigned length, char *reuAddress, char *cpuAddress)</CODE></P>
<P><CODE>void FetchRAM (char bank, unsigned length, char *reuAddress, char *cpuAddress)</CODE></P>
<P><CODE>void SwapRAM (char bank, unsigned length, char *reuAddress, char *cpuAddress)</CODE></P>
<P><CODE> char VerifyRAM (char bank, unsigned length, char *reuAddress, char *cpuAddress)</CODE></P>
<P>These functions are the interface to a REU - Ram Expansion Unit. I think that they are self-explanatory.
You can check for REU presence by taking the value of <CODE>ramExpSize</CODE>. You have to do it before
using any of these functions.</P>

<H2><A NAME="ss3.8">3.8</A> <A HREF="geos.html#toc3.8">Processes and Multitasking</A>
</H2>

<P>Weird? Not at all. GEOS has some limited multitasking ability. You can set up a chain of functions
called in specified intervals and you can put the main program to sleep without disturbing other
tasks and making the user interface unresponsive.</P>

<H3>InitProcesses</H3>

<P><CODE>void InitProcesses (char number, struct process *processTab)</CODE></P>
<P>This is the main initialization routine. After calling it processes are set up, but not
enabled. The parameters for <CODE>InitProcesses</CODE> are:
<UL>
<LI><CODE>number</CODE> - number of processes</LI>
<LI><CODE>processTab</CODE> - a table of <CODE>struct process</CODE>, with size equal to <CODE>number</CODE></LI>
</UL>
</P>
<P>A single task is described by an entry in <CODE>processTab</CODE>, it contains two values - a <CODE>pointer</CODE> to
the task function and a number of <CODE>jiffies</CODE> which describe the delay between calls to task. On PAL
systems there are 50 jiffies per second, while on NTSC there are 60.</P>
<P>The maximum number of tasks is 20. Be warned that GEOS doesn't check if parameters are valid and
if <CODE>processTab</CODE> would be too large it would overwrite existing data in GEOS space.</P>
<P>There's one important thing - the last entry in <CODE>processTab</CODE> has to be <CODE>NULL,NULL</CODE>, so the
maximum size of <CODE>processTab</CODE> is equal to 21.</P>
<P>See the description of <CODE>process</CODE> structure for a more detailed discussion on this.</P>

<H3>RestartProcess and EnableProcess</H3>

<P><CODE>void RestartProcess (char processNumber)</CODE></P>
<P><CODE>void EnableProcess (char processNumber)</CODE></P>
<P>These two functions start the task counter. <CODE>RestartProcess</CODE> should be called for each process
after <CODE>InitProcesses</CODE>, because it resets all flags and counters and it starts the counters.</P>
<P><CODE>RestartProcess</CODE> enables the counters and sets their initial value to that given in <CODE>processTab</CODE>.</P>
<P><CODE>EnableProcess</CODE> forces the given process to execute by simulating the timer expiring.</P>

<H3>BlockProcess and UnblockProcess</H3>

<P><CODE>void BlockProcess (char processNumber)</CODE></P>
<P><CODE>void UnblockProcess (char processNumber)</CODE></P>
<P><CODE>BlockProcess</CODE> disables the execution of the given process, but this does not disable the timers.
It means that if you call <CODE>UnblockProcess</CODE> before the timer runs out, the process will be executed.</P>
<P><CODE>UnblockProcess</CODE> does the opposite.</P>

<H3>FreezeProcess and UnfreezeProcess</H3>

<P><CODE>void FreezeProcess (char processNumber)</CODE></P>
<P><CODE>void UnfreezeProcess (char processNumber)</CODE></P>
<P><CODE>FreezeProcess</CODE> disables timer for given process. <CODE>UnfreezeProcess</CODE> does the opposite.
This is not equal to <CODE>RestartProcess</CODE> as timers are not reloaded with initial value.</P>

<H3>Sleep</H3>

<P><CODE>void Sleep (unsigned jiffies)</CODE></P>
<P>This function is a multitasking sleep - the program is halted, but it doesn't block other functions
e.g. callbacks from menus and icons.
The only argument here is the number of jiffies to wait until the app will wake up. It depends on the
video mode (PAL or NTSC) how many jiffies there are per second (50 or 60, respectively).
If you don't want to worry about it and need only full second resolution, call the standard
<CODE>sleep</CODE> function from <CODE>unistd.h</CODE>.</P>

<H2><A NAME="ss3.9">3.9</A> <A HREF="geos.html#toc3.9">System Functions</A>
</H2>

<H3>FirstInit</H3>

<P><CODE>void FirstInit (void)</CODE></P>
<P>This function initializes some GEOS variables and mouse parameters. This is called on GEOS boot
up. You shouldn't use this unless you know what you are doing.</P>

<H3>InitForIO and DoneWithIO</H3>

<P><CODE>void InitForIO (void)</CODE></P>
<P><CODE>void DoneWithIO (void)</CODE></P>
<P>These functions are called by some disk routines. You should call them only if you want to
do something with IO registers or call one of the Kernal ROM routines. Note that this is rather an
expensive way of turning off IRQs and enabling IO.</P>

<H3>MainLoop</H3>

<P><CODE>void MainLoop (void)</CODE></P>
<P>Returns control to the system. Any code between call to <CODE>MainLoop</CODE> and the end of current
function will never be executed. When in <CODE>MainLoop</CODE> the system waits for your action - using
icons, keyboard or menus to force some specific action from the program. You have to define
proper handlers before that.</P>

<H3>EnterDeskTop</H3>

<P><CODE>void EnterDeskTop (void)</CODE></P>
<P>This is an alias for <CODE>exit(0)</CODE> so you will never burn yourself. Anyway, you should not
use it. Always use <CODE>exit()</CODE> instead. Library destructors and functions registered with
<CODE>atexit()</CODE> are called.</P>

<H3>ToBASIC</H3>

<P><CODE>void ToBASIC (void)</CODE></P>
<P>This one is another way of terminating an application - forcing GEOS to shutdown and exit to BASIC.
I was considering whether to include it or not, but maybe someone will need it - which I doubt.</P>
<P><EM>WARNING:</EM> library destructors and functions registered with <CODE>atexit()</CODE> will not be called
so it is quite unsafe way to terminate your program.</P>

<H3>Panic</H3>

<P><CODE>void Panic (void)</CODE></P>
<P>This calls system's <CODE>Panic</CODE> handler - it shows a dialog box with the message
<BLOCKQUOTE><CODE>
<PRE>
System error at:xxxx
</PRE>
</CODE></BLOCKQUOTE>

where <CODE>xxxx</CODE> is last known execution address (caller). By default this is bound to the <CODE>BRK</CODE>
instruction, but it might be usable in debugging as kind of <CODE>assert</CODE>. (Note that <CODE>assert</CODE>
is available as a separate function and will give you more information than that).</P>
<P>The system is halted after a call to <CODE>Panic</CODE> which means that library destructors will not be
called and some data may be lost (no wonder you're panicking).</P>

<H3>CallRoutine</H3>

<P><CODE>void CallRoutine (void *myFunct)</CODE></P>
<P>This is a system caller routine. You need to provide a pointer to a function and it will be immediately
called, unless the pointer is equal to <CODE>NULL</CODE>. This is the main functionality of this function -
you don't need to check if the pointer is valid.</P>

<H3>GetSerialNumber</H3>

<P><CODE>unsigned GetSerialNumber (void)</CODE></P>
<P>This function returns the serial number of the system. It might be used for copy-protection.
However, please remember that Free Software is a true power and you are using it right now.</P>

<H3>GetRandom</H3>

<P><CODE>char GetRandom (void)</CODE></P>
<P>This function returns a random number. It can be also read from <CODE>random</CODE> e.g.
<BLOCKQUOTE><CODE>
<PRE>
a=random;
</PRE>
</CODE></BLOCKQUOTE>

but by calling this function you are sure that the results will be always different.
<CODE>random</CODE> is updated once a frame (50Hz PAL) and on every call to <CODE>GetRandom</CODE>.</P>
<P>Note that this is not the same as the <CODE>rand</CODE> function from the standard library. <CODE>GetRandom</CODE>
will give you unpredictable results (if IRQs occur between calls to it) while
<CODE>rand</CODE> conforms to the standard and for a given seed (<CODE>srand</CODE>) always returns with the
same sequence of values.</P>

<H3>SetDevice</H3>

<P><CODE>void SetDevice (char device)</CODE></P>
<P>This function sets the current device to the given. It might be used together with <CODE>InitForIO</CODE>,
<CODE>DoneWithIO</CODE> and some Kernal routines. Unless the new device is a disk drive this only sets
new value in <CODE>curDevice</CODE>, in the other case new disk driver is loaded from REU or internal RAM.</P>

<H3>get_ostype</H3>

<P><CODE>char get_ostype (void)</CODE></P>
<P>This function returns the GEOS Kernal version combined (by logical OR) with the machine type. Read
<CODE>gsys.h</CODE> for definitions of the returned values.</P>

<H3>get_tv</H3>

<P><CODE>char get_tv (void)</CODE></P>
<P>This function returns the PAL/NTSC flag combined (by logical OR) with the 40/80 columns flag. This is
not the best way to check if the screen has 40 or 80 columns since a PAL/NTSC check is always
performed and it can take as long as a full raster frame. If you just want to know if the 
screen has 40 or 80 columns use the expression <CODE>graphMode &amp; 0x80</CODE> which returns <CODE>0</CODE> for
40 columns and <CODE>0x80</CODE> for 80 columns. Remember that this value can be changed during
runtime. It is unclear if this will work for GEOS 64 so you probably do not want to test
anything if not running under GEOS128. Use <CODE>get_ostype</CODE> to check it. Read <CODE>gsys.h</CODE> for
definitions of the returned values.</P>

<HR>
<A HREF="geos-4.html">Next</A>
<A HREF="geos-2.html">Previous</A>
<A HREF="geos.html#toc3">Contents</A>
</BODY>
</HTML>
